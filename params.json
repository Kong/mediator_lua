{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Mediator lua","tagline":"Event Management for Clean & Decoupled Code","body":"mediator\\_lua\r\n===========\r\n\r\nVersion 1.0\r\n\r\nFor more information, please see \r\n\r\n[View the project on Github](https://github.com/OlivineLabs/mediator_lua)\r\n\r\n[View the documentation](http://olivinelabs.com/mediator_lua)\r\n\r\nIf you have [luarocks](http://luarocks.org), isntall it with `luarocks install mediator_lua`.\r\nIf you don't, get it. If you really don't want to, just copy mediator.lua from the \r\n[Git repository](https://github.com/OlivineLabs/mediator_lua).\r\n\r\nA utility class to help you manage events.\r\n------------------------------------------\r\n\r\nmediator\\_lua is a simple class that allows you to listen to events by subscribing to\r\nand sending data to channels. Its purpose is to help you decouple code where you\r\nmight otherwise have functions calling functions calling functions, and instead\r\nsimply call `mediator.publish(\"chat\", { message = \"hi\" })`\r\n\r\nWhy?\r\n----\r\n\r\nMy specific use case: manage HTTP routes called in OpenResty. There's an excellent \r\narticle that talks about the Mediator pattern (in Javascript) in more in detail by \r\n[Addy Osmani](http://addyosmani.com/largescalejavascript/#mediatorpattern)\r\n(that made me go back and refactor this code a bit.)\r\n\r\nUsage\r\n-----\r\n\r\nYou can register events with the mediator two ways: using channels, or with a \r\n*predicate* to perform more complex matching (a predicate is a function that\r\nreturns a true/false value that determines if mediator should run the callback.) \r\n\r\nInstantiate a new mediator, and then you can being subscribing, removing, and publishing.\r\n\r\nExample:\r\n\r\n```lua\r\nMediator = require \"mediator_lua\"\r\nmediator = Mediator() # instantiate a new mediator\r\n\r\nmediator:publish(channel, <data, data, ... >)\r\nmediator:remove(<channel>) \r\n```\r\n\r\nSubscription signature:\r\n\r\n```lua\r\n(channel, callback, <options>, <context>);\r\n```\r\n\r\nCallback signature:\r\n\r\n```lua\r\nfunction(<data, data ...>, channel);\r\n```\r\n\r\nMediator:subscribe `options` (all are optional; default is empty):\r\n\r\n\r\n```lua\r\n{\r\n  predicate = function(arg1, arg2) return arg1 == arg2 end\r\n  priority = 0|1|... (array index; max of callback array length, min of 0)\r\n}\r\n```\r\n\r\nWhen you call `subscribe`, you get a `subscriber` object back that you can use to\r\nupdate and change options. It looks like:\r\n\r\n\r\n```lua\r\n{\r\n  id, # unique identifier\r\n  fn, # function you passed in\r\n  options, # options\r\n  context, # context for fn to be called within\r\n  channel, # provides a pointer back to its channel\r\n  update(options) # function that accepts { fn, options, context }\r\n}\r\n```\r\n\r\nExamples:\r\n\r\n\r\n```lua\r\nMediator = require(\"mediator_lua\")\r\nlocal mediator = Mediator()\r\n\r\n# Print data when the \"message\" channel is published to\r\n# Subscribe returns a \"Subscriber\" object\r\nmediator:subscribe(\"message\", function(data) print(data) end);\r\nmediator:publish(\"message\", \"Hello, world\");\r\n\r\n  >> Hello, world\r\n\r\n# Print the message when the predicate function returns true\r\nlocal predicate = function(data) return data.From == \"Jack\" end\r\nmediator.Subscribe(\"channel\", function(data) print(data.Message) end, { predicate = predicate });\r\nmediator.Publish(\"channel\", { Message = \"Hey!\", From = \"Jack\" })\r\nmediator.Publish(\"channel\", { Message = \"Hey!\", From = \"Drew\" })\r\n\r\n  >> Hey!\r\n```\r\n\r\nYou can remove events by passing in a type or predicate, and optionally the \r\nfunction to remove.\r\n\r\n\r\n```lua\r\n# removes all methods bound to a channel \r\nmediator:remove(\"channel\")\r\n\r\n# unregisters MethodFN, a named function we defined elsewhere, from \"channel\" \r\nmediator:remove(\"channel\", MethodFN)\r\n```\r\n\r\nYou can call the registered functions with the `publish` method, which accepts \r\nan args array:\r\n\r\n\r\n```lua\r\nmediator:publish(\"channel\", \"argument\", \"another one\", { etc: true }); # args go on forever\r\n```\r\n\r\nYou can namespace your subscribing / removing / publishing. This will recurisevely\r\ncall children, and also subscribers to direct parents.\r\n\r\n\r\n```lua\r\nmediator:subscribe(\"application:chat:receiveMessage\", function(data){ ... })\r\n\r\n# will recursively call anything in the appllication:chat:receiveMessage namespace \r\n# will also call thins directly subscribed to application and application:chat,\r\n# but not their children\r\nmediator:publish(\"application:chat:receiveMessage\", \"Jack Lawson\", \"Hey\")\r\n\r\n# will recursively remove everything under application:chat\r\nmediator:remove(\"application:chat\")\r\n```\r\n\r\nYou can update Subscriber priority:\r\n\r\n\r\n```lua\r\nlocal sub = mediator:subscribe(\"application:chat\", function(data){ ... })\r\nlocal sub2 = mediator:subscribe(\"application:chat\", function(data){ ... })\r\n\r\n# have sub2 executed first\r\nmediator.GetChannel(\"application:chat\").SetPriority(sub2.id, 0);\r\n```\r\n\r\nYou can update Subscriber callback, context, and/or options:\r\n\r\n\r\n```lua\r\nsub:update({ fn: ..., context = { }, options = { ... })\r\n```\r\n\r\nYou can stop the chain of execution by calling channel:stopPropagation()\r\n\r\n\r\n```lua\r\n# for example, let's not post the message if the `from` and `to` are the same\r\nmediator.Subscribe(\"application:chat\", function(data, channel) \r\n  # throw an error message or something\r\n  channel:stopPropagation()\r\nend, options = {\r\n  predicate = function(data) return data.From == data.To end,\r\n  priority = 0\r\n})\r\n```\r\n\r\n\r\nTesting\r\n-------\r\n\r\nUses [lunit](http://www.nessie.de/mroth/lunit/) for testing; you can install it\r\nthrough [luarocks](http://luarocks.org).\r\n\r\nContributing\r\n------------\r\n\r\nBuild stuff, run the tests, then submit a pull request with comments and a\r\ndescription of what you've done, and why.\r\n\r\nLicense\r\n-------\r\nThis code and its accompanying README and are \r\n[MIT licensed](http://www.opensource.org/licenses/mit-license.php). \r\n\r\n\r\nIn Closing\r\n----------\r\nHave fun, and please submit suggestions and improvements! You can leave any \r\nissues here, or contact me on Twitter (@ajacksified).","google":"UA-22050912-1"}